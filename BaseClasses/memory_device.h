/*! \file memory_device.h
 *  \brief Заголовочный файл с описанием класса MemoryDevice
 *  \details Содержит объявление абстрактного класса MemoryDevice, представляющего
 *           устройство памяти с простым текстовым буфером. Класс определяет интерфейс
 *           для установки и получения размера памяти, а также предоставляет базовые
 *           операции записи, чтения и очистки данных. Предназначен для моделирования
 *           энергонезависимой или временной памяти в симуляциях и тестах.
 */
#ifndef MEMORYDEVICE
#define MEMORYDEVICE
#include <string>

/*! \class MemoryDevice
 *  \brief Абстрактный интерфейс устройства памяти
 *  \details MemoryDevice задаёт контракт для конкретных реализаций устройств памяти,
 *           требуя реализации методов управления размером памяти. Класс также реализует
 *           простую текстовую область хранения данных с операциями записи, чтения и очистки,
 *           которые могут быть использованы в тестах и моделях устройств.
 */
class MemoryDevice {
public:
    /*! \brief Виртуальный деструктор
     *  \details Обеспечивает корректное разрушение наследников через указатель на базовый класс.
     */
    virtual ~MemoryDevice() = default;

    /*! \brief Установить размер памяти
     *  \param size Размер памяти в ГБ
     *  \details Чисто виртуальный метод, который обязаны реализовать производные классы
     *           для изменения конфигурации объёма доступной памяти.
     */
    virtual void SetMemorySize(int size) = 0;

    /*! \brief Получить текущий размер памяти
     *  \return Размер памяти в ГБ
     *  \details Чисто виртуальный метод, возвращающий текущее значение объёма памяти.
     */
    virtual int GetMemorySize() const = 0;

    /*! \brief Записать текстовые данные в внутренний буфер
     *  \param data Строка данных для записи
     *  \details Метод добавляет переданную строку в внутренний буфер с переводом строки.
     *           Реализация пригодна для простых тестовых сценариев и логирования.
     */
    void WriteData(const std::string &data) {
        this->data_ += data + "\n";
    }

    /*! \brief Прочитать содержимое внутреннего буфера
     *  \return Строка с накопленными данными
     *  \details Возвращает текущее содержимое текстового буфера без изменений.
     */
    std::string ReadData() const {
        return this->data_;
    }

    /*! \brief Очистить внутренний буфер данных
     *  \details Сбрасывает текстовый буфер в пустое состояние.
     */
    void ClearData() {
        this->data_ = "";
    }

protected:
    std::string data_{""}; /*!< Внутренний текстовый буфер для записи данных */
};

#endif
